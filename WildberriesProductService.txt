package com.wbozon.wb.service;

import com.wbozon.wb.client.WildberriesWireHousesClient;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import com.wbozon.wb.client.WildberriesPriceClient;
import com.wbozon.wb.client.WildberriesStockClient;
import com.wbozon.wb.api.classes.ProductCard;
import com.wbozon.wb.api.classes.WareHouseEntity;
import com.wbozon.wb.api.classes.StockEntity;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Slf4j
@Getter
public class WildberriesProductService {
    private final ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    private final List<StockEntity> resultStocks = new ArrayList<>();
    private final AtomicInteger priceProgress = new AtomicInteger(0);
    private final AtomicInteger stockProgress = new AtomicInteger(0);
    private final WildberriesWireHousesClient wareHousesClient;
    private final WildberriesPriceClient priceClient;
    private final WildberriesStockClient stockClient;
    private final ProductCardService productCardService;
    private final int STOCKS_BATCH_SIZE = 1000;
    private final List<WareHouseEntity> listWareHouses = new ArrayList<>();

    public WildberriesProductService(ProductCardService productCardService,
            WildberriesWireHousesClient wareHousesClient,
            WildberriesPriceClient priceClient,
            WildberriesStockClient stockClient) {
        this.productCardService = productCardService;
        this.wareHousesClient = wareHousesClient;
        this.priceClient = priceClient;
        this.stockClient = stockClient;
        updateWarehouses();
    }

    public void updateWarehouses() {
        try {
            listWareHouses.clear();
            List<WareHouseEntity> warehouses = wareHousesClient.fetchWarehouses();
            listWareHouses.addAll(warehouses);
            log.info("–ü–æ–ª—É—á–∏–ª–∏ {} —Å–∫–ª–∞–¥–æ–≤", listWareHouses.size());
        } catch (Exception e) {
            log.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–∫–ª–∞–¥–æ–≤", e);
            // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–≥–ª—É—à–∫—É –∏–ª–∏ –ª–æ–≥–∏–∫—É –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è
           // addFallbackWarehouses();
        }
    }

    private void addFallbackWarehouses() {
        // –î–æ–±–∞–≤–ª—è–µ–º —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —Å–∫–ª–∞–¥ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        WareHouseEntity defaultWarehouse = new WareHouseEntity();
        defaultWarehouse.setId(12345L); // ID –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        defaultWarehouse.setName("–°–∫–ª–∞–¥ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é");
        listWareHouses.add(defaultWarehouse);
        log.warn("–ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–∫–ª–∞–¥ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è");
    }

    /*
     * public void syncPricesAsync(String token) {
     * List<Long> nmIDs = new
     * ArrayList<>(productCardService.getAllCards().keySet());
     * int batchSize = 1000;
     * List<List<Long>> batches = partitionList(nmIDs, batchSize);
     * 
     * priceProgress.set(0);
     * int total = batches.size();
     * 
     * List<CompletableFuture<Void>> futures = new ArrayList<>();
     * 
     * for (List<Long> batch : batches) {
     * CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
     * try {
     * Map<Long, ListGood> prices = priceClient.fetchPrices(token, batch);
     * for (Map.Entry<Long, ListGood> entry : prices.entrySet()) {
     * ProductCard card = productCardService.getAllCards().get(entry.getKey());
     * if (card != null) {
     * card.setPrice(entry.getValue().getPrice());
     * card.setDiscount(entry.getValue().getDiscount());
     * }
     * }
     * int done = priceProgress.incrementAndGet();
     * System.out.printf("üìä –¶–µ–Ω—ã: %d/%d –ø–∞–∫–µ—Ç–æ–≤ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ%n", done, total);
     * } catch (Exception e) {
     * System.err.println("‚ùå –û—à–∏–±–∫–∞ –≤ –ø–∞–∫–µ—Ç–µ —Ü–µ–Ω: " + e.getMessage());
     * }
     * }, executor);
     * futures.add(future);
     * }
     * 
     * CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
     * System.out.println("‚úÖ –í—Å–µ —Ü–µ–Ω—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã");
     * }
     */
    public void syncStocksAsync() {
        List<ProductCard> cards = new ArrayList<>(productCardService.getAllCards().values());
        // Extract all SKUs efficiently
        List<String> allSkus = cards.parallelStream()
                .filter(Objects::nonNull)
                .flatMap(card -> card.getSizes() != null ? card.getSizes().stream() : Stream.empty())
                .filter(Objects::nonNull)
                .flatMap(size -> size.getSkus() != null ? Arrays.stream(size.getSkus()) : Stream.empty())
                .filter(Objects::nonNull)
                .distinct()
                .collect(Collectors.toList());
        stockProgress.set(0);
        // int total = warehouses.size();

        List<CompletableFuture<Void>> futures = new ArrayList<>();

        for (WareHouseEntity warehouse : listWareHouses) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                try {
                    int batchSize = STOCKS_BATCH_SIZE;
                    long batchStartTime = System.currentTimeMillis();
                    for (int i = 0; i < allSkus.size(); i += batchSize) {
                        List<String> batchSkus = allSkus.subList(i, Math.min(i + batchSize, allSkus.size()));
                        List<StockEntity> stocks = stockClient.fetchStocks(warehouse.getId(), batchSkus);
                        // stocksReceived += stocks.size();
                        resultStocks.addAll(stocks);
                        long batchTime = System.currentTimeMillis() - batchStartTime;
                        if (i % 5000 == 0 || i + batchSize >= allSkus.size()) {
                            log.debug("Warehouse {}: processed {} SKUs, received {} stocks, batch time: {} ms",
                                    warehouse.getName(), Math.min(i + batchSize, allSkus.size()), resultStocks.size(),
                                    batchTime);
                        }

                    }
                } catch (Exception e) {
                    System.err.printf("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –æ—Å—Ç–∞—Ç–∫–æ–≤ –¥–ª—è —Å–∫–ª–∞–¥–∞ %s: %s%n", warehouse.getName(),
                            e.getMessage());
                }
            }, executor);
            futures.add(future);
        }

        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();
        System.out.println("‚úÖ –í—Å–µ –æ—Å—Ç–∞—Ç–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã");
    }

    private <T> List<List<T>> partitionList(List<T> list, int batchSize) {
        List<List<T>> partitions = new ArrayList<>();
        for (int i = 0; i < list.size(); i += batchSize) {
            partitions.add(list.subList(i, Math.min(i + batchSize, list.size())));
        }
        return partitions;
    }

}
